// Code generated by iprotogen. DO NOT EDIT.
package iprototypes

import (
	"encoding/binary"
	"fmt"
	"math"
	"slices"

	iproto "github.com/my-mail-ru/go-iproto"
)

func (recvBER BER) MarshalIProto(buf []byte) ([]byte, error) {
	buf = iproto.EncodeBER(buf, uint64(recvBER))
	return buf, nil
}
func (recv_BER *BER) UnmarshalIProto(buf []byte) ([]byte, error) {
	var (
		u64 uint64
		err error
	)
	u64, buf, err = iproto.DecodeBER(buf)
	if err != nil {
		return nil, err
	}
	*recv_BER = BER(u64)
	return buf, nil
}
func (recvBytes Bytes) MarshalIProto(buf []byte) ([]byte, error) {
	buf = iproto.EncodeBER(buf, uint64(len(recvBytes)))
	buf = append(buf, recvBytes...)
	return buf, nil
}
func (recv_Bytes *Bytes) UnmarshalIProto(buf []byte) ([]byte, error) {
	var (
		u64 uint64
		err error
	)
	u64, buf, err = iproto.DecodeBER(buf)
	if err != nil {
		return nil, err
	}
	len_recv_Bytes := int(u64)
	if len(buf) < len_recv_Bytes {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Bytes: %w: %d < %d", iproto.ErrOverflow, len(buf), len_recv_Bytes)
	}
	*recv_Bytes = Bytes(slices.Clone(buf[:len_recv_Bytes]))
	buf = buf[len_recv_Bytes:]
	return buf, nil
}
func (recvFloat32 Float32) MarshalIProto(buf []byte) ([]byte, error) {
	bitsRecvFloat32 := math.Float32bits(float32(recvFloat32))
	buf = append(buf, byte(bitsRecvFloat32), byte(bitsRecvFloat32>>8), byte(bitsRecvFloat32>>16), byte(bitsRecvFloat32>>24))
	return buf, nil
}
func (recv_Float32 *Float32) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 4 {
		return nil, fmt.Errorf("UnmarshalIProto: Bits_recv_Float32: %w: %d < %d", iproto.ErrOverflow, len(buf), 4)
	}
	bits_recv_Float32 := binary.LittleEndian.Uint32(buf)
	buf = buf[4:]
	*recv_Float32 = Float32(math.Float32frombits(bits_recv_Float32))
	return buf, nil
}
func (recvFloat64 Float64) MarshalIProto(buf []byte) ([]byte, error) {
	bitsRecvFloat64 := math.Float64bits(float64(recvFloat64))
	buf = append(buf, byte(bitsRecvFloat64), byte(bitsRecvFloat64>>8), byte(bitsRecvFloat64>>16), byte(bitsRecvFloat64>>24), byte(bitsRecvFloat64>>32), byte(bitsRecvFloat64>>40), byte(bitsRecvFloat64>>48), byte(bitsRecvFloat64>>56))
	return buf, nil
}
func (recv_Float64 *Float64) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 8 {
		return nil, fmt.Errorf("UnmarshalIProto: Bits_recv_Float64: %w: %d < %d", iproto.ErrOverflow, len(buf), 8)
	}
	bits_recv_Float64 := binary.LittleEndian.Uint64(buf)
	buf = buf[8:]
	*recv_Float64 = Float64(math.Float64frombits(bits_recv_Float64))
	return buf, nil
}
func (recvInt16 Int16) MarshalIProto(buf []byte) ([]byte, error) {
	buf = append(buf, byte(recvInt16), byte(recvInt16>>8))
	return buf, nil
}
func (recv_Int16 *Int16) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 2 {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Int16: %w: %d < %d", iproto.ErrOverflow, len(buf), 2)
	}
	*recv_Int16 = Int16(binary.LittleEndian.Uint16(buf))
	buf = buf[2:]
	return buf, nil
}
func (recvInt32 Int32) MarshalIProto(buf []byte) ([]byte, error) {
	buf = append(buf, byte(recvInt32), byte(recvInt32>>8), byte(recvInt32>>16), byte(recvInt32>>24))
	return buf, nil
}
func (recv_Int32 *Int32) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 4 {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Int32: %w: %d < %d", iproto.ErrOverflow, len(buf), 4)
	}
	*recv_Int32 = Int32(binary.LittleEndian.Uint32(buf))
	buf = buf[4:]
	return buf, nil
}
func (recvInt64 Int64) MarshalIProto(buf []byte) ([]byte, error) {
	buf = append(buf, byte(recvInt64), byte(recvInt64>>8), byte(recvInt64>>16), byte(recvInt64>>24), byte(recvInt64>>32), byte(recvInt64>>40), byte(recvInt64>>48), byte(recvInt64>>56))
	return buf, nil
}
func (recv_Int64 *Int64) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 8 {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Int64: %w: %d < %d", iproto.ErrOverflow, len(buf), 8)
	}
	*recv_Int64 = Int64(binary.LittleEndian.Uint64(buf))
	buf = buf[8:]
	return buf, nil
}
func (recvInt8 Int8) MarshalIProto(buf []byte) ([]byte, error) {
	buf = append(buf, byte(recvInt8))
	return buf, nil
}
func (recv_Int8 *Int8) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 1 {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Int8: %w: %d < %d", iproto.ErrOverflow, len(buf), 1)
	}
	*recv_Int8 = Int8(buf[0])
	buf = buf[1:]
	return buf, nil
}
func (recvSlice Slice) MarshalIProto(buf []byte) ([]byte, error) {
	var err error
	buf = iproto.EncodeBER(buf, uint64(len(recvSlice)))
	for _, elemRecvSlice := range recvSlice {
		buf, err = elemRecvSlice.MarshalIProto(buf)
		if err != nil {
			return nil, err
		}
	}
	return buf, nil
}
func (recv_Slice *Slice) UnmarshalIProto(buf []byte) ([]byte, error) {
	var (
		u64 uint64
		err error
	)
	u64, buf, err = iproto.DecodeBER(buf)
	if err != nil {
		return nil, err
	}
	len_recv_Slice := int(u64)
	if len(buf) < len_recv_Slice {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Slice: %w: %d < %d", iproto.ErrOverflow, len(buf), len_recv_Slice)
	}
	*recv_Slice = make([]iproto.MarshalerUnmarshaler, len_recv_Slice)
	for i_recv_Slice := 0; i_recv_Slice < len_recv_Slice; i_recv_Slice++ {
		buf, err = (*recv_Slice)[i_recv_Slice].UnmarshalIProto(buf)
		if err != nil {
			return nil, err
		}
	}
	return buf, nil
}
func (recvString String) MarshalIProto(buf []byte) ([]byte, error) {
	buf = iproto.EncodeBER(buf, uint64(len(recvString)))
	buf = append(buf, recvString...)
	return buf, nil
}
func (recv_String *String) UnmarshalIProto(buf []byte) ([]byte, error) {
	var (
		u64 uint64
		err error
	)
	u64, buf, err = iproto.DecodeBER(buf)
	if err != nil {
		return nil, err
	}
	len_recv_String := int(u64)
	if len(buf) < len_recv_String {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_String: %w: %d < %d", iproto.ErrOverflow, len(buf), len_recv_String)
	}
	*recv_String = String(buf[:len_recv_String])
	buf = buf[len_recv_String:]
	return buf, nil
}
func (recvUint16 Uint16) MarshalIProto(buf []byte) ([]byte, error) {
	buf = append(buf, byte(recvUint16), byte(recvUint16>>8))
	return buf, nil
}
func (recv_Uint16 *Uint16) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 2 {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Uint16: %w: %d < %d", iproto.ErrOverflow, len(buf), 2)
	}
	*recv_Uint16 = Uint16(binary.LittleEndian.Uint16(buf))
	buf = buf[2:]
	return buf, nil
}
func (recvUint32 Uint32) MarshalIProto(buf []byte) ([]byte, error) {
	buf = append(buf, byte(recvUint32), byte(recvUint32>>8), byte(recvUint32>>16), byte(recvUint32>>24))
	return buf, nil
}
func (recv_Uint32 *Uint32) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 4 {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Uint32: %w: %d < %d", iproto.ErrOverflow, len(buf), 4)
	}
	*recv_Uint32 = Uint32(binary.LittleEndian.Uint32(buf))
	buf = buf[4:]
	return buf, nil
}
func (recvUint64 Uint64) MarshalIProto(buf []byte) ([]byte, error) {
	buf = append(buf, byte(recvUint64), byte(recvUint64>>8), byte(recvUint64>>16), byte(recvUint64>>24), byte(recvUint64>>32), byte(recvUint64>>40), byte(recvUint64>>48), byte(recvUint64>>56))
	return buf, nil
}
func (recv_Uint64 *Uint64) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 8 {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Uint64: %w: %d < %d", iproto.ErrOverflow, len(buf), 8)
	}
	*recv_Uint64 = Uint64(binary.LittleEndian.Uint64(buf))
	buf = buf[8:]
	return buf, nil
}
func (recvUint8 Uint8) MarshalIProto(buf []byte) ([]byte, error) {
	buf = append(buf, byte(recvUint8))
	return buf, nil
}
func (recv_Uint8 *Uint8) UnmarshalIProto(buf []byte) ([]byte, error) {
	if len(buf) < 1 {
		return nil, fmt.Errorf("UnmarshalIProto: *recv_Uint8: %w: %d < %d", iproto.ErrOverflow, len(buf), 1)
	}
	*recv_Uint8 = Uint8(buf[0])
	buf = buf[1:]
	return buf, nil
}
