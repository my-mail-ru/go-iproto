package iprotogen

import (
	"bytes"
	"go/ast"
	"go/printer"
	"go/token"
	"log"
	"maps"
	"path"
	"path/filepath"
	"regexp"
	"slices"
	"strconv"
	"strings"

	goimports "golang.org/x/tools/imports"
)

const (
	iprotogenBanner = "// Code generated by iprotogen. DO NOT EDIT."
	testSuffix      = "_test"
	generatedSuffix = "_generated"
)

var (
	identAppend          = ast.NewIdent("append")
	identBlank           = ast.NewIdent("_")
	identBuf             = ast.NewIdent("buf")
	identByte            = ast.NewIdent("byte")
	identErr             = ast.NewIdent("err")
	identError           = ast.NewIdent("error")
	identFloat32         = ast.NewIdent("float32")
	identFloat64         = ast.NewIdent("float64")
	identIProto          = ast.NewIdent("iproto")
	identLen             = ast.NewIdent("len")
	identMake            = ast.NewIdent("make")
	identMarshalIProto   = ast.NewIdent("MarshalIProto")
	identMath            = ast.NewIdent("math")
	identNew             = ast.NewIdent("new")
	identNil             = ast.NewIdent("nil")
	identU64             = ast.NewIdent("u64")
	identInt             = ast.NewIdent("int")
	identUint32          = ast.NewIdent("uint32")
	identUint64          = ast.NewIdent("uint64")
	identUnmarshalIProto = ast.NewIdent("UnmarshalIProto")

	exprFmtErrorf       = exprDot(ast.NewIdent("fmt"), ast.NewIdent("Errorf"))
	exprErrOverflow     = exprDot(identIProto, ast.NewIdent("ErrOverflow"))
	exprEncodeBER       = exprDot(identIProto, ast.NewIdent("EncodeBER"))
	exprDecodeBER       = exprDot(identIProto, ast.NewIdent("DecodeBER"))
	exprFloat32bits     = exprDot(identMath, ast.NewIdent("Float32bits"))
	exprFloat64bits     = exprDot(identMath, ast.NewIdent("Float64bits"))
	exprFloat32frombits = exprDot(identMath, ast.NewIdent("Float32frombits"))
	exprFloat64frombits = exprDot(identMath, ast.NewIdent("Float64frombits"))
	exprLittleEndian    = exprDot(ast.NewIdent("binary"), ast.NewIdent("LittleEndian"))
	exprClone           = exprDot(ast.NewIdent("slices"), ast.NewIdent("Clone"))
	exprLenBuf          = exprCall(identLen, identBuf)
	exprBytes           = &ast.ArrayType{Elt: identByte}
	exprBufErr          = []ast.Expr{identBuf, identErr}
	exprBuf0            = &ast.IndexExpr{X: identBuf, Index: lit0}

	lit0 = litInt(0)
	lit1 = litInt(1)
)

// vars that have to be declared explicitly using the var statement
var lhsVars = map[string]*ast.Ident{
	identErr.Name: identError,
	identU64.Name: identUint64,
}

type File struct {
	Directives  string // before the package token
	PkgName     string
	ImportByPkg map[string]string   // pkg -> alias
	ImportAlias map[string]struct{} // the same file shouldn't be processed in parallel, so using goro-unsafe maps seems to be ok
	Decls       []Decl
}

type fileEmitOptions struct {
	disableFormatting bool
}

type FileEmitOptionsFunc func(*fileEmitOptions)

func WithDisableFormatting(opt *fileEmitOptions) {
	opt.disableFormatting = true
}

func (file File) Emit(optFuncs ...FileEmitOptionsFunc) ([]byte, error) {
	var opt fileEmitOptions

	for _, f := range optFuncs {
		f(&opt)
	}

	astDecls := make([]ast.Decl, 0, len(file.Decls))
	imports := make([]*ast.ImportSpec, 0, len(file.ImportByPkg))
	specs := make([]ast.Spec, 0, len(file.ImportByPkg))

	for pkgPath, alias := range file.ImportByPkg {
		spec := &ast.ImportSpec{Path: litStr(pkgPath)}
		if alias != "" {
			spec.Name = ast.NewIdent(alias)
		}

		imports = append(imports, spec)
		specs = append(specs, spec)
	}

	astDecls = append(astDecls, &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: specs,
	})

	for _, decl := range file.Decls {
		astDecls = decl.EmitMarshalerDecl(astDecls)
		astDecls = decl.EmitUnmarshalerDecl(astDecls)
	}

	f := &ast.File{
		Name:    ast.NewIdent(file.PkgName),
		Imports: imports,
		Decls:   astDecls,
	}

	buf := &bytes.Buffer{}
	buf.WriteString(iprotogenBanner + "\n\n")
	buf.WriteString(file.Directives)

	if err := printer.Fprint(buf, token.NewFileSet(), f); err != nil {
		return nil, err
	}

	bytes := buf.Bytes()
	if opt.disableFormatting {
		return bytes, nil
	}

	return goimports.Process(".", bytes, nil)
}

type Decl struct {
	TypeIdent *ast.Ident
	Type      Type
}

func (d Decl) EmitMarshalerDecl(decls []ast.Decl) []ast.Decl {
	return emitMethDecl(d.Type, d.TypeIdent, identMarshalIProto, d.Type.EmitMarshaler, decls)
}

func (d Decl) EmitUnmarshalerDecl(decls []ast.Decl) []ast.Decl {
	return emitMethDecl(d.Type, &ast.StarExpr{X: d.TypeIdent}, identUnmarshalIProto, dereference(d.Type.EmitUnmarshaler), decls)
}

func newBlock() []ast.Stmt {
	return make([]ast.Stmt, 0, 64)
}

func dereference(f func(ast.Expr, []ast.Stmt) []ast.Stmt) func(ast.Expr, []ast.Stmt) []ast.Stmt {
	return func(x ast.Expr, block []ast.Stmt) []ast.Stmt {
		return f(&ast.StarExpr{X: x}, block)
	}
}

func emitMethDecl(typ Type, receiverType ast.Expr, methName *ast.Ident, emit func(x ast.Expr, block []ast.Stmt) []ast.Stmt, decls []ast.Decl) []ast.Decl {
	if _, ok := typ.(Custom); ok {
		return decls
	}

	receiver := varFromExpr(receiverType, "recv")
	body := emit(receiver, newBlock())

	if body == nil {
		return decls
	}

	return append(decls, &ast.FuncDecl{
		Name: methName,
		Recv: &ast.FieldList{
			List: []*ast.Field{{
				Names: []*ast.Ident{receiver},
				Type:  receiverType,
			}},
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{{
					Names: []*ast.Ident{identBuf},
					Type:  exprBytes,
				}},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{Type: exprBytes},
					{Type: identError},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: emitReturn(fixVarDecl(body)),
		},
	})
}

// vars that are assigned together with `buf` must be declared explicitly, because DEFINE (:=) assignments
// can cause `buf` var shadowing
func fixVarDecl(block []ast.Stmt) []ast.Stmt {
	v := &lhsVarVisitor{
		specs:       make([]ast.Spec, 0, len(lhsVars)),
		lhsVarsCurr: maps.Clone(lhsVars),
	}

	ast.Walk(v, &ast.BlockStmt{List: block})

	if len(v.specs) == 0 {
		return block
	}

	return slices.Insert(block, 0, ast.Stmt(&ast.DeclStmt{
		Decl: &ast.GenDecl{
			Tok:   token.VAR,
			Specs: v.specs,
		},
	}))
}

type lhsVarVisitor struct {
	specs       []ast.Spec
	lhsVarsCurr map[string]*ast.Ident // it's ok since ast.Walk isn't parallel (sure?)
}

func (v *lhsVarVisitor) Visit(node ast.Node) ast.Visitor {
	if node == nil {
		return nil
	}

	assign, ok := node.(*ast.AssignStmt)
	if !ok {
		return v
	}

	for _, lhsExpr := range assign.Lhs {
		varIdent, ok := lhsExpr.(*ast.Ident)
		if !ok {
			continue
		}

		typ, ok := v.lhsVarsCurr[varIdent.Name]
		if !ok {
			continue
		}

		delete(v.lhsVarsCurr, varIdent.Name)

		v.specs = append(v.specs, &ast.ValueSpec{
			Names: []*ast.Ident{varIdent},
			Type:  typ,
		})
	}

	return nil
}

func litInt(x int) *ast.BasicLit {
	return &ast.BasicLit{
		Kind:  token.INT,
		Value: strconv.Itoa(x),
	}
}

func litInt64(x int64) *ast.BasicLit {
	return &ast.BasicLit{
		Kind:  token.INT,
		Value: strconv.FormatInt(x, 10),
	}
}

func litUint64(x uint64) *ast.BasicLit {
	return &ast.BasicLit{
		Kind:  token.INT,
		Value: strconv.FormatUint(x, 10),
	}
}

func litStr(s string) *ast.BasicLit {
	return &ast.BasicLit{
		Kind:  token.STRING,
		Value: strconv.Quote(s),
	}
}

func emitBoundCheck(x ast.Expr, op token.Token, limitExpr ast.Expr, isMarshal bool, errTitle string, block []ast.Stmt) []ast.Stmt {
	if isMarshal {
		errTitle = "MarshalIProto: " + errTitle
	} else {
		errTitle = "UnmarshalIProto: " + errTitle
	}

	return append(block, &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			Op: op,
			X:  x,
			Y:  limitExpr,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						identNil,
						exprCall(
							exprFmtErrorf,
							litStr(errTitle+": %w: %d "+op.String()+" %d"),
							exprErrOverflow,
							x,
							limitExpr,
						),
					},
				},
			},
		},
	})
}

func emitLenMarshal(x ast.Expr, lenType Integer, block []ast.Stmt) []ast.Stmt {
	return lenType.EmitMarshaler(exprCall(identLen, x), block)
}

func emitReturn(block []ast.Stmt) []ast.Stmt {
	return append(block, &ast.ReturnStmt{
		Results: []ast.Expr{
			identBuf,
			identNil,
		},
	})
}

func stmtErrCheck() ast.Stmt {
	return &ast.IfStmt{
		Cond: &ast.BinaryExpr{
			Op: token.NEQ,
			X:  identErr,
			Y:  identNil,
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{identNil, identErr},
				},
			},
		},
	}
}

func emitAppendBuf(appendArgs []ast.Expr, ellipsis token.Pos, block []ast.Stmt) []ast.Stmt {
	return append(block, stmtAssign(identBuf, &ast.CallExpr{
		Fun:      identAppend,
		Args:     appendArgs,
		Ellipsis: ellipsis,
	}))
}

// emit ASSIGN (=) for complex expressions (struct fields, slice elems etc), or DEFINE (:=) for simple var idents
func emitVarAssign(lhs, rhs ast.Expr, block []ast.Stmt) []ast.Stmt {
	tok := token.ASSIGN
	if _, ok := lhs.(*ast.Ident); ok {
		tok = token.DEFINE
	}

	return append(
		block,
		&ast.AssignStmt{
			Tok: tok,
			Lhs: []ast.Expr{lhs},
			Rhs: []ast.Expr{rhs},
		},
	)
}

func astToSource(x any) string {
	src := &strings.Builder{}
	if err := printer.Fprint(src, token.NewFileSet(), x); err != nil {
		log.Fatal(err)
	}

	return src.String()
}

func astToSourceUpper(x any) string {
	src := astToSource(x)
	return strings.ToUpper(src[:1]) + src[1:] // seems to be faster than strings.Title
}

var rxNotAlphaNum = regexp.MustCompile(`\W`)

func varFromExpr(x ast.Expr, prefix string) *ast.Ident {
	src := astToSourceUpper(x)
	src = rxNotAlphaNum.ReplaceAllString(src, "_")

	return ast.NewIdent(prefix + src)
}

func newImportMaps() (map[string]string, map[string]struct{}) {
	byPkg := map[string]string{
		iprotoPackage:     "iproto",
		"fmt":             "",
		"math":            "",
		"slices":          "",
		"encoding/binary": "",
	}

	byAlias := make(map[string]struct{}, len(byPkg))

	for pkg, alias := range byPkg {
		if alias == "" {
			alias = path.Base(pkg) // valid for stdlib pkgs only
		}

		byAlias[alias] = struct{}{}
	}

	return byPkg, byAlias
}

// grep -rs '&ast\.'|sed 's/.*\(&ast\.[^{]*\).*/\1/'|sort|uniq -c|sort -n

func exprCall(fun ast.Expr, args ...ast.Expr) *ast.CallExpr {
	return &ast.CallExpr{
		Fun:  fun,
		Args: args,
	}
}

func exprDot(x ast.Expr, sel *ast.Ident) *ast.SelectorExpr {
	return &ast.SelectorExpr{X: x, Sel: sel}
}

// fieldSelector returns SelectorExpr applying pointer selector sugar: (*x).Sel -> x.Sel
func fieldSelector(x ast.Expr, sel *ast.Ident) *ast.SelectorExpr {
	if star, ok := x.(*ast.StarExpr); ok {
		x = star.X
	}

	return &ast.SelectorExpr{X: x, Sel: sel}
}

func stmtAssign(lhs, rhs ast.Expr) *ast.AssignStmt {
	return &ast.AssignStmt{
		Tok: token.ASSIGN,
		Lhs: []ast.Expr{lhs},
		Rhs: []ast.Expr{rhs},
	}
}

func stmtDefine(lhs, rhs ast.Expr) *ast.AssignStmt {
	return &ast.AssignStmt{
		Tok: token.DEFINE,
		Lhs: []ast.Expr{lhs},
		Rhs: []ast.Expr{rhs},
	}
}

func stmtBufRewind(lenExpr ast.Expr) *ast.AssignStmt {
	return stmtAssign(identBuf, &ast.SliceExpr{
		X:   identBuf,
		Low: lenExpr,
	})
}

func stmtFor(counterVar, maxExpr ast.Expr, body []ast.Stmt) *ast.ForStmt {
	return &ast.ForStmt{ // pre-go1.22 compat
		Init: stmtDefine(counterVar, lit0),
		Cond: &ast.BinaryExpr{
			Op: token.LSS,
			X:  counterVar,
			Y:  maxExpr,
		},
		Post: &ast.IncDecStmt{
			X:   counterVar,
			Tok: token.INC,
		},
		Body: &ast.BlockStmt{List: body},
	}
}

func isUint8(typ ast.Expr) bool {
	return isUintN(typ, 1)
}

func isUint64(typ ast.Expr) bool {
	return isUintN(typ, 8)
}

func isUintN(typ ast.Expr, n int) bool {
	ident, ok := typ.(*ast.Ident)
	if !ok {
		return false
	}

	switch n {
	case 1:
		return isByte(ident.Name)
	case 2:
		return ident.Name == "uint16"
	case 4:
		return ident.Name == "uint32"
	case 8:
		return ident.Name == "uint64"
	}

	return false
}

func isByteSlice(typ ast.Expr) bool {
	arr, ok := typ.(*ast.ArrayType)
	if !ok || arr.Len != nil {
		return false
	}

	ident, ok := arr.Elt.(*ast.Ident)
	if !ok {
		return false
	}

	return isByte(ident.Name)
}

func isByte(name string) bool {
	return name == "uint8" || name == "byte"
}

func isIdent(expr ast.Expr, name string) bool {
	ident, ok := expr.(*ast.Ident)
	if !ok {
		return false
	}

	return ident.Name == name
}

func GeneratedFileName(fname string) string {
	suffix := len(fname) - len(filepath.Ext(fname))

	if strings.HasSuffix(fname[:suffix], testSuffix) {
		suffix -= len(testSuffix)
	}

	return fname[:suffix] + generatedSuffix + fname[suffix:]
}
